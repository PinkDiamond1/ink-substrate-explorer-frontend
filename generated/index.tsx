// THIS IS A GENERATED FILE, use `pnpm codegen` to regenerate
/* tslint:disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type Block = {
  __typename?: 'Block';
  hash: Scalars['String'];
  number: Scalars['Int'];
  parentHash: Scalars['String'];
  timestamp: Scalars['Float'];
  transactions: Array<Transaction>;
};

export type Contract = {
  __typename?: 'Contract';
  address: Scalars['String'];
  events: Array<Event>;
  metadata?: Maybe<Scalars['String']>;
};

export type Event = {
  __typename?: 'Event';
  data?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  index: Scalars['String'];
  method: Scalars['String'];
  section: Scalars['String'];
  timestamp: Scalars['Float'];
  topics: Scalars['String'];
  transactionHash?: Maybe<Scalars['String']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  uploadMetadata: Scalars['Boolean'];
};


export type MutationUploadMetadataArgs = {
  contractAddress: Scalars['String'];
  metadata: Scalars['String'];
};

export type Query = {
  __typename?: 'Query';
  decodeEvents: Scalars['String'];
  getBlock: Block;
  getBlocks: Array<Block>;
  getContract: Contract;
  getEvents: Array<Event>;
  getTransaction: Transaction;
  getTransactions: Array<Transaction>;
  status: Scalars['String'];
};


export type QueryDecodeEventsArgs = {
  contractAddress: Scalars['String'];
};


export type QueryGetBlockArgs = {
  hash: Scalars['String'];
};


export type QueryGetBlocksArgs = {
  orderAsc?: InputMaybe<Scalars['Boolean']>;
  orderByNumber?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryGetContractArgs = {
  address: Scalars['String'];
};


export type QueryGetEventsArgs = {
  contract?: InputMaybe<Scalars['String']>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  transactionHash?: InputMaybe<Scalars['String']>;
};


export type QueryGetTransactionArgs = {
  hash: Scalars['String'];
};


export type QueryGetTransactionsArgs = {
  blockHash?: InputMaybe<Scalars['String']>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};

export type Transaction = {
  __typename?: 'Transaction';
  blockHash?: Maybe<Scalars['String']>;
  events: Array<Event>;
  /** Transaction hash */
  hash: Scalars['String'];
  method: Scalars['String'];
  /** Transaction's nonce */
  nonce?: Maybe<Scalars['Int']>;
  section: Scalars['String'];
  /** Signature generated by the signer */
  signature: Scalars['String'];
  /** Address of the signer */
  signer?: Maybe<Scalars['String']>;
  timestamp: Scalars['Float'];
  /** Extra gas paid for the Tx as tip */
  tip?: Maybe<Scalars['Int']>;
};

export type GetBlocksQueryVariables = Exact<{
  skip: Scalars['Int'];
  take: Scalars['Int'];
  orderByNumber?: InputMaybe<Scalars['Boolean']>;
  orderAsc?: InputMaybe<Scalars['Boolean']>;
}>;


export type GetBlocksQuery = { __typename?: 'Query', getBlocks: Array<{ __typename?: 'Block', hash: string, number: number, parentHash: string, timestamp: number, transactions: Array<{ __typename?: 'Transaction', hash: string }> }> };

export type GetTransactionsQueryVariables = Exact<{
  skip: Scalars['Int'];
  take: Scalars['Int'];
}>;


export type GetTransactionsQuery = { __typename?: 'Query', getTransactions: Array<{ __typename?: 'Transaction', blockHash?: string | null, hash: string, method: string, nonce?: number | null, section: string, signature: string, signer?: string | null, timestamp: number, tip?: number | null, events: Array<{ __typename?: 'Event', method: string, section: string }> }> };


export const GetBlocksDocument = gql`
    query getBlocks($skip: Int!, $take: Int!, $orderByNumber: Boolean, $orderAsc: Boolean) {
  getBlocks(
    skip: $skip
    take: $take
    orderByNumber: $orderByNumber
    orderAsc: $orderAsc
  ) {
    hash
    number
    parentHash
    timestamp
    transactions {
      hash
    }
  }
}
    `;

/**
 * __useGetBlocksQuery__
 *
 * To run a query within a React component, call `useGetBlocksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBlocksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBlocksQuery({
 *   variables: {
 *      skip: // value for 'skip'
 *      take: // value for 'take'
 *      orderByNumber: // value for 'orderByNumber'
 *      orderAsc: // value for 'orderAsc'
 *   },
 * });
 */
export function useGetBlocksQuery(baseOptions: Apollo.QueryHookOptions<GetBlocksQuery, GetBlocksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBlocksQuery, GetBlocksQueryVariables>(GetBlocksDocument, options);
      }
export function useGetBlocksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBlocksQuery, GetBlocksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBlocksQuery, GetBlocksQueryVariables>(GetBlocksDocument, options);
        }
export type GetBlocksQueryHookResult = ReturnType<typeof useGetBlocksQuery>;
export type GetBlocksLazyQueryHookResult = ReturnType<typeof useGetBlocksLazyQuery>;
export type GetBlocksQueryResult = Apollo.QueryResult<GetBlocksQuery, GetBlocksQueryVariables>;
export const GetTransactionsDocument = gql`
    query getTransactions($skip: Int!, $take: Int!) {
  getTransactions(skip: $skip, take: $take) {
    blockHash
    events {
      method
      section
    }
    hash
    method
    nonce
    section
    signature
    signer
    timestamp
    tip
  }
}
    `;

/**
 * __useGetTransactionsQuery__
 *
 * To run a query within a React component, call `useGetTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTransactionsQuery({
 *   variables: {
 *      skip: // value for 'skip'
 *      take: // value for 'take'
 *   },
 * });
 */
export function useGetTransactionsQuery(baseOptions: Apollo.QueryHookOptions<GetTransactionsQuery, GetTransactionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTransactionsQuery, GetTransactionsQueryVariables>(GetTransactionsDocument, options);
      }
export function useGetTransactionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTransactionsQuery, GetTransactionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTransactionsQuery, GetTransactionsQueryVariables>(GetTransactionsDocument, options);
        }
export type GetTransactionsQueryHookResult = ReturnType<typeof useGetTransactionsQuery>;
export type GetTransactionsLazyQueryHookResult = ReturnType<typeof useGetTransactionsLazyQuery>;
export type GetTransactionsQueryResult = Apollo.QueryResult<GetTransactionsQuery, GetTransactionsQueryVariables>;